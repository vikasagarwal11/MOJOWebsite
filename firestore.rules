rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // --- Helpers ---
    function isSignedIn() {
      return request.auth != null;
    }
    
    function userDoc() {
      return isSignedIn() ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data : null;
    }
    
    function isAdmin() {
      return userDoc() != null && userDoc().role == 'admin';
    }
    
    function isMember() {
      return userDoc() != null && userDoc().role == 'member';
    }
    
    // Enhanced user blocking functions
    function isUserBlockedFromRsvp(userId) { 
      return exists(/databases/$(database)/documents/users/$(userId)) &&
        get(/databases/$(database)/documents/users/$(userId)).data.blockedFromRsvp == true; 
    }
    
    function isUserBlocked(currentUserId, targetUserId) {
      let blockDoc = get(/databases/$(database)/documents/userBlocks/$(currentUserId + '_' + targetUserId));
      return blockDoc != null && blockDoc.data.isActive == true;
    }
    
    function isUserBlockedBy(currentUserId, targetUserId) {
      let blockDoc = get(/databases/$(database)/documents/userBlocks/$(targetUserId + '_' + currentUserId));
      return blockDoc != null && blockDoc.data.isActive == true;
    }
    
    // Check if users can interact (not blocked by each other)
    function canInteract(currentUserId, targetUserId) {
      return currentUserId == targetUserId || 
        (!isUserBlocked(currentUserId, targetUserId) && !isUserBlockedBy(currentUserId, targetUserId));
    }
    
    // Phone number utilities (may be used in future rules)
    function tokenPhone() { 
      return isSignedIn() ? request.auth.token.phone_number : null; 
    }
    
    function isBlockedPhone() {
      return isSignedIn() && request.auth.token.phone_number == "+10000000000";
    }
    
    function isNonEmptyString(v) {
      return v is string && v.size() > 0;
    }
    
    function isUrlLike(v) {
      return v is string && v.size() <= 2048 && v.matches('https?://.*');
    }
    
    function validAddress(m) {
      return m is map && 
        ('city' in m) && isNonEmptyString(m.city) && 
        ('state' in m) && isNonEmptyString(m.state) && 
        (!('street' in m) || m.street is string) && 
        (!('postalCode' in m) || m.postalCode is string);
    }
    
    function validSocial(m) {
      return m is map && 
        m.keys().hasOnly(['instagram','facebook','twitter','tiktok','youtube','website']) && 
        (!('instagram' in m) || isUrlLike(m.instagram)) && 
        (!('facebook' in m) || isUrlLike(m.facebook)) && 
        (!('twitter' in m) || isUrlLike(m.twitter)) && 
        (!('tiktok' in m) || isUrlLike(m.tiktok)) && 
        (!('youtube' in m) || isUrlLike(m.youtube)) && 
        (!('website' in m) || isUrlLike(m.website));
    }
    
    function validUserProfileData(newData) {
      return (!('displayName' in newData) || isNonEmptyString(newData.displayName)) && 
        (!('email' in newData) || newData.email is string) && 
        (!('photoURL' in newData) || isUrlLike(newData.photoURL)) && 
        (!('about' in newData) || (newData.about is string && newData.about.size() <= 1000)) && 
        (!('age' in newData) || (newData.age is number && newData.age >= 13 && newData.age <= 120)) && 
        (!('address' in newData) || validAddress(newData.address)) && 
        (!('social' in newData) || validSocial(newData.social)) &&
        (!('fcmToken' in newData) || (newData.fcmToken is string && newData.fcmToken.size() > 0));
    }
    
    // Enhanced event validation
    function validEventData(newData) {
      return isNonEmptyString(newData.title) && 
        newData.title.size() <= 200 &&
        isNonEmptyString(newData.description) && 
        newData.description.size() <= 2000 &&
        newData.startAt is timestamp &&
        (!('endAt' in newData) || newData.endAt is timestamp) &&
        (!('tags' in newData) || (newData.tags is list && newData.tags.size() <= 10)) &&
        (!('location' in newData) || isNonEmptyString(newData.location)) &&
        (!('maxAttendees' in newData) || (newData.maxAttendees is number && newData.maxAttendees > 0)) &&
        (!('attendingCount' in newData) || (newData.attendingCount is number && newData.attendingCount >= 0)) &&
        (!('invitedUserIds' in newData) || (newData.invitedUserIds is list && newData.invitedUserIds.size() <= 100)) &&
        (!('titleLower' in newData) || isNonEmptyString(newData.titleLower)) &&
        (!('allDay' in newData) || newData.allDay is bool) &&
        (!('imageUrl' in newData) || (newData.imageUrl is string || newData.imageUrl == null)) &&
        (!('visibility' in newData) || newData.visibility in ['public', 'members', 'private']);
    }
    
    // Check if user is event creator
    function isEventCreator(eventId) {
      return isSignedIn() && 
        exists(/databases/$(database)/documents/events/$(eventId)) &&
        get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid;
    }
    
    // Enhanced RSVP validation functions
    function validRSVPData(data) {
      return data is map &&
        ('eventId' in data) && isNonEmptyString(data.eventId) &&
        ('userId' in data) && isNonEmptyString(data.userId) &&
        ('status' in data) && data.status in ['going', 'not-going', 'pending'] &&
        (!('adults' in data) || (data.adults is number && data.adults >= 0)) &&
        // childCounts can be:
        //  (A) list of maps: [{ageGroup:'0-2', count:1}, ...] (max 4), OR
        //  (B) map keyed by age group: {'0-2':1,'3-5':0,'6-10':2,'11':0}
        (!('childCounts' in data) ||
          (data.childCounts is list &&
           data.childCounts.size() <= 4 &&
           data.childCounts.size() >= 0 &&
           (data.childCounts.size() == 0 ||
             (data.childCounts[0] is map &&
              ('ageGroup' in data.childCounts[0]) &&
              ('count' in data.childCounts[0])))) ||
          (data.childCounts is map)) &&
        (!('guests' in data) || (data.guests is list && data.guests.size() <= 20)) &&
        (!('notes' in data) || (data.notes is string && data.notes.size() <= 1000)) &&
        (!('displayName' in data) || (data.displayName is string || data.displayName == null)) &&
        (!('email' in data) || (data.email is string || data.email == null));
    }
    
    // Enhanced attendee validation functions
    function validAttendeeData(data) {
      return data is map &&
        ('eventId' in data) && isNonEmptyString(data.eventId) &&
        ('userId' in data) && isNonEmptyString(data.userId) &&
        ('attendeeType' in data) && data.attendeeType in ['primary', 'family_member', 'guest'] &&
        ('relationship' in data) && data.relationship in ['self', 'spouse', 'child', 'guest'] &&
        ('name' in data) && isNonEmptyString(data.name) && data.name.size() >= 2 &&
        ('ageGroup' in data) && data.ageGroup in ['0-2', '3-5', '6-10', '11+', 'adult'] &&
        ('rsvpStatus' in data) && data.rsvpStatus in ['going', 'not-going', 'pending'] &&
        (!('familyMemberId' in data) || (data.familyMemberId is string || data.familyMemberId == null));
    }
    
    function validStatusHistory(history) {
      return history is list && 
         history.size() > 0 && 
         history[0] is map &&
         history[0].status is string &&
         history[0].status in ['going', 'not-going'] &&
         history[0].changedAt is timestamp && // Firestore converts Date to timestamp automatically
         history[0].changedBy is string;
    }
    
    // --- USERS ---
    match /users/{userId} {
      allow read: if isSignedIn() || 
        // Allow public read for basic user info (same as shown in events)
        (resource.data.keys().hasOnly(['displayName', 'photoURL', 'displayNameLower', 'firstName', 'lastName']));
      allow create: if isSignedIn() && 
        request.auth.uid == userId && 
        (!('role' in request.resource.data) || (request.resource.data.role == 'member' && !isBlockedPhone())) && 
        validUserProfileData(request.resource.data);
      allow update: if isSignedIn() && (
        (request.auth.uid == userId && 
         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role']) && 
         validUserProfileData(request.resource.data)) ||
        (isAdmin() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['blockedFromRsvp', 'updatedAt', 'fcmToken']) &&
         (!('fcmToken' in request.resource.data) || request.resource.data.fcmToken is string))
      );
      allow delete: if isSignedIn() && request.auth.uid == userId;
      
      // --- FAMILY MEMBERS ---
      match /familyMembers/{memberId} {
        allow read, write: if isSignedIn() && request.auth.uid == userId;
      }
    }
    
    // --- EVENT TEASERS ---
    match /event_teasers/{teaserId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }
    
    // --- USER BLOCKS ---
    match /userBlocks/{blockId} {
      allow read: if isSignedIn() && (
        request.auth.uid == resource.data.blockedByUserId || 
        request.auth.uid == resource.data.blockedUserId ||
        isAdmin()
      );
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.blockedByUserId;
      allow update: if isSignedIn() && (
        request.auth.uid == resource.data.blockedByUserId ||
        isAdmin()
      );
      allow delete: if isAdmin();
    }
    
    // --- BLOCK REPORTS ---
    match /blockReports/{reportId} {
      allow read: if isSignedIn() && (
        request.auth.uid == resource.data.reporterUserId ||
        isAdmin()
      );
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.reporterUserId;
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // --- MANUAL FIXES (Admin System Tools) ---
    match /manual_fixes/{fixId} {
      allow read, create, update, delete: if isAdmin();
    }
    
    // --- EVENTS (Enhanced) ---
    match /events/{eventId} {
      allow read: if
        // Past events: always readable by everyone (for history)
        resource.data.startAt < request.time ||
        // Public events: readable by everyone (including events with missing fields)
        (('visibility' in resource.data) && resource.data.visibility == 'public') ||
        // Legacy support: old 'public' field
        (('public' in resource.data) && resource.data.public == true) ||
        // Authenticated users can see events they're allowed to access
        (isSignedIn() && (
          // Event creator can see their own events
          resource.data.createdBy == request.auth.uid ||
          // Admin can see all events
          isAdmin() ||
          // Members can see members-only events
          (isMember() && (('visibility' in resource.data) && resource.data.visibility == 'members')) ||
          // Invited users can see private events (handle missing fields)
          (('invitedUserIds' in resource.data) && request.auth.uid in resource.data.invitedUserIds) ||
          // Legacy support: old invitedUsers field
          (('invitedUsers' in resource.data) && request.auth.uid in resource.data.invitedUsers)
        ));
      
      // Enhanced create/update/delete permissions
      allow create: if isSignedIn() && 
        (isMember() || isAdmin()) && 
        request.auth.uid == request.resource.data.createdBy &&
        validEventData(request.resource.data);
      
      allow update: if isSignedIn() && 
        (isAdmin() || isEventCreator(eventId) ||
         // Allow users to update only specific fields for RSVP purposes
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attendingCount', 'updatedAt'])));
      
      allow delete: if isSignedIn() && 
        (isAdmin() || isEventCreator(eventId));
      
      // Enhanced RSVP management with blocking support
      match /rsvps/{userId} {
        allow read: if isSignedIn();
        
        allow create: if (isMember() || isAdmin()) && 
          request.auth.uid == userId && 
          request.resource.data.eventId == eventId &&
          request.resource.data.userId == userId &&
          // Simple permission check: allow RSVP if user can see the event
          (
            // Public events: anyone can RSVP
            get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'public' ||
            // Event creator can always RSVP
            request.auth.uid == get(/databases/$(database)/documents/events/$(eventId)).data.createdBy ||
            // Invited users can RSVP to private events
            (get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'private' && 
             request.auth.uid in get(/databases/$(database)/documents/events/$(eventId)).data.invitedUserIds)
          );
        
        allow update: if (isMember() || isAdmin()) &&
          (request.auth.uid == userId || isAdmin()) &&
          request.resource.data.eventId == eventId &&
          request.resource.data.userId == userId &&
          validRSVPData(request.resource.data);
        
        // Enhanced: Allow admins to modify any RSVP
        allow delete: if (isMember() || isAdmin()) && 
          (request.auth.uid == userId || isAdmin());
      }

      // Attendees subcollection - NEW!
      match /attendees/{attendeeId} {
        allow read: if isSignedIn() && (
          // Event creator can read all attendees
          get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid ||
          // Admin can read all attendees
          isAdmin() ||
          // User can read attendees for events they can access
          (
            // Public events: anyone can read
            get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'public' ||
            // Members can read members-only events
            (isMember() && get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'members') ||
            // Invited users can read private events
            (get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'private' && 
             request.auth.uid in get(/databases/$(database)/documents/events/$(eventId)).data.invitedUserIds)
          )
        );
        
        allow create: if isSignedIn() && (
          // User can manage their own household attendees
          request.resource.data.userId == request.auth.uid ||
          // Event creator can manage all attendees
          get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid ||
          // Admin can manage all attendees
          isAdmin()
        ) && validAttendeeData(request.resource.data);
        
        allow update: if isSignedIn() && (
          // User can manage their own household attendees
          request.resource.data.userId == request.auth.uid ||
          // Event creator can manage all attendees
          get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid ||
          // Admin can manage all attendees
          isAdmin()
        ) && validAttendeeData(request.resource.data);
        
        allow delete: if isSignedIn() && (
          // User can manage their own household attendees
          resource.data.userId == request.auth.uid ||
          // Event creator can manage all attendees
          get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid ||
          // Admin can manage all attendees
          isAdmin()
        );
      }
    }
    
    // --- RSVPs Collection Group Access (for cross-event queries) ---
    // Allow users to read/write their own RSVP docs across all events
    match /{path=**}/rsvps/{rsvpId} {
      allow read, get, list: if request.auth != null
                              && (resource.data.userId == request.auth.uid || 
                                  // Allow event creators to read RSVPs for their events
                                  (resource.data.eventId != null && 
                                   exists(/databases/$(database)/documents/events/$(resource.data.eventId)) &&
                                   get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.createdBy == request.auth.uid));
      
      // Allow users to create/update their own RSVPs (delegated to subcollection rules)
      allow create: if false; // Use specific subcollection rules instead
      allow update: if false; // Use specific subcollection rules instead
      allow delete: if false; // Use specific subcollection rules instead
    }
    
    // --- POSTS ---
    match /posts/{postId} {
      allow read: if (('isPublic' in resource.data) && resource.data.isPublic == true) || 
        isMember() || isAdmin();
      
      allow create: if isSignedIn() && 
        (isMember() || isAdmin()) && 
        request.auth.uid == request.resource.data.authorId;
      
      allow update, delete: if isSignedIn() && 
        (request.auth.uid == resource.data.authorId || isAdmin());
      
      match /likes/{userId} {
        allow read: if true;
        allow create: if (isMember() || isAdmin()) && 
          request.auth.uid == userId && 
          request.resource.data.keys().hasOnly(['userId','createdAt']) && 
          request.resource.data.userId == userId;
        allow update: if false;
        allow delete: if (isMember() || isAdmin()) && 
          (request.auth.uid == userId || isAdmin());
      }
      
      match /comments/{commentId} {
        allow read: if true;
        allow create: if isSignedIn() && 
          request.auth.uid == request.resource.data.authorId && 
          isNonEmptyString(request.resource.data.text) && 
          request.resource.data.text.size() <= 1000 && 
          request.resource.data.keys().hasOnly(['authorId','authorName','text','createdAt']);
        allow update: if isSignedIn() && 
          (request.auth.uid == resource.data.authorId || isAdmin()) && 
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['text','updatedAt']);
        allow delete: if isSignedIn() && 
          (request.auth.uid == resource.data.authorId || isAdmin());
      }
    }
    
    // --- MEDIA ---
    match /media/{mediaId} {
      allow read: if (resource.data.isPublic == true) || isMember() || isAdmin();
      allow create: if isSignedIn() && 
        request.auth.uid == request.resource.data.uploadedBy;
      allow update, delete: if isSignedIn() && 
        (request.auth.uid == resource.data.uploadedBy || isAdmin()) ||
        // Allow view counter updates for all users (including guests)
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewsCount']));
      
      match /likes/{userId} {
        allow read: if true;
        allow create: if (isMember() || isAdmin()) && 
          request.auth.uid == userId && 
          request.resource.data.keys().hasOnly(['userId','createdAt']) && 
          request.resource.data.userId == userId;
        allow update: if false;
        allow delete: if (isMember() || isAdmin()) && 
          (request.auth.uid == userId || isAdmin());
      }
      
      match /comments/{commentId} {
        allow read: if true;
        allow create: if isSignedIn() && 
          request.auth.uid == request.resource.data.authorId && 
          isNonEmptyString(request.resource.data.text) && 
          request.resource.data.text.size() <= 1000 && 
          request.resource.data.keys().hasOnly(['authorId','authorName','text','createdAt']);
        allow update: if isSignedIn() && 
          (request.auth.uid == resource.data.authorId || isAdmin()) && 
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['text','updatedAt']);
        allow delete: if isSignedIn() && 
          (request.auth.uid == resource.data.authorId || isAdmin());
      }
    }
    
    // --- SPONSORS ---
    match /sponsors/{sponsorId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
      
      match /promotions/{promotionId} {
        allow read: if true;
        allow create, update, delete: if isAdmin();
      }
    }
    
    // --- NOTIFICATIONS (Enhanced) ---
    match /notifications/{notificationId} {
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      
      // Allow admins to create notifications (for system notifications)
      allow create: if isAdmin();
      
      // Allow users to update only their own notifications (mark as read)
      allow update: if request.auth != null && 
        request.auth.uid == resource.data.userId && 
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['read', 'updatedAt']);
      
      // Allow admins to delete notifications
      allow delete: if isAdmin();
    }
    
    // --- Fallback for stray comments ---
    match /{parentPath=**}/comments/{commentId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && 
        request.auth.uid == request.resource.data.authorId && 
        isNonEmptyString(request.resource.data.text) && 
        request.resource.data.text.size() <= 1000;
      allow update, delete: if isSignedIn() && 
        (request.auth.uid == resource.data.authorId || isAdmin());
    }
    
    // --- Default Security: Deny all unknown collections ---
    match /{document=**} {
      allow read, write: if false;
    }
  }
}