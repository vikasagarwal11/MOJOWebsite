rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // --- Helpers ---
    function isSignedIn() {
      return request.auth != null;
    }
    
    function userDoc() {
      return isSignedIn() ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data : null;
    }
    
    function isAdmin() {
      return userDoc() != null && userDoc().role == 'admin';
    }
    
    function isMember() {
      return userDoc() != null && userDoc().role == 'member';
    }
    
    // Enhanced user blocking functions
    function isUserBlockedFromRsvp(userId) { 
      return exists(/databases/$(database)/documents/users/$(userId)) &&
        ('blockedFromRsvp' in get(/databases/$(database)/documents/users/$(userId)).data) &&
        get(/databases/$(database)/documents/users/$(userId)).data.blockedFromRsvp == true; 
    }
    
    function isUserBlocked(currentUserId, targetUserId) {
      let blockDoc = get(/databases/$(database)/documents/userBlocks/$(currentUserId + '_' + targetUserId));
      return blockDoc != null && blockDoc.data.isActive == true;
    }
    
    function isUserBlockedBy(currentUserId, targetUserId) {
      let blockDoc = get(/databases/$(database)/documents/userBlocks/$(targetUserId + '_' + currentUserId));
      return blockDoc != null && blockDoc.data.isActive == true;
    }
    
    // Check if users can interact (not blocked by each other)
    function canInteract(currentUserId, targetUserId) {
      return currentUserId == targetUserId || 
        (!isUserBlocked(currentUserId, targetUserId) && !isUserBlockedBy(currentUserId, targetUserId));
    }
    
    // Phone number utilities (may be used in future rules)
    function tokenPhone() { 
      return isSignedIn() ? request.auth.token.phone_number : null; 
    }
    
    function isBlockedPhone() {
      return isSignedIn() && request.auth.token.phone_number == "+10000000000";
    }
    
    function isNonEmptyString(v) {
      return v is string && v.size() > 0;
    }
    
    function isUrlLike(v) {
      return v is string && v.size() <= 2048 && v.matches('https?://.*');
    }

    function isValidRating(r) {
      return r is number && r >= 1 && r <= 5;
    }

    function isAllowedTestimonialStatus(status) {
      return status == 'pending' || status == 'published' || status == 'rejected';
    }
    
    function validAddress(m) {
      return m is map && 
        ('city' in m) && isNonEmptyString(m.city) && 
        ('state' in m) && isNonEmptyString(m.state) && 
        (!('street' in m) || m.street is string) && 
        (!('postalCode' in m) || m.postalCode is string);
    }
    
    function validSocial(m) {
      return m is map && 
        m.keys().hasOnly(['instagram','facebook','twitter','tiktok','youtube','website']) && 
        (!('instagram' in m) || isUrlLike(m.instagram)) && 
        (!('facebook' in m) || isUrlLike(m.facebook)) && 
        (!('twitter' in m) || isUrlLike(m.twitter)) && 
        (!('tiktok' in m) || isUrlLike(m.tiktok)) && 
        (!('youtube' in m) || isUrlLike(m.youtube)) && 
        (!('website' in m) || isUrlLike(m.website));
    }
    
    function validUserProfileData(newData) {
      return (!('displayName' in newData) || isNonEmptyString(newData.displayName)) && 
        (!('email' in newData) || newData.email is string) && 
        (!('photoURL' in newData) || isUrlLike(newData.photoURL)) && 
        (!('about' in newData) || (newData.about is string && newData.about.size() <= 1000)) && 
        (!('age' in newData) || (newData.age is number && newData.age >= 13 && newData.age <= 120)) && 
        (!('address' in newData) || validAddress(newData.address)) && 
        (!('social' in newData) || validSocial(newData.social)) &&
        (!('fcmToken' in newData) || (newData.fcmToken is string && newData.fcmToken.size() > 0));
    }
    
    // Enhanced event validation
    function validEventData(newData) {
      return isNonEmptyString(newData.title) && 
        newData.title.size() <= 200 &&
        isNonEmptyString(newData.description) && 
        newData.description.size() <= 2000 &&
        newData.startAt is timestamp &&
        (!('endAt' in newData) || newData.endAt is timestamp) &&
        (!('tags' in newData) || (newData.tags is list && newData.tags.size() <= 10)) &&
        (!('location' in newData) || isNonEmptyString(newData.location)) &&
        (!('maxAttendees' in newData) || (newData.maxAttendees is number && newData.maxAttendees > 0)) &&
        (!('attendingCount' in newData) || (newData.attendingCount is number && newData.attendingCount >= 0)) &&
        (!('waitlistCount' in newData) || (newData.waitlistCount is number && newData.waitlistCount >= 0)) &&
        (!('invitedUserIds' in newData) || (newData.invitedUserIds is list && newData.invitedUserIds.size() <= 100)) &&
        (!('titleLower' in newData) || isNonEmptyString(newData.titleLower)) &&
        (!('allDay' in newData) || newData.allDay is bool) &&
        (!('imageUrl' in newData) || (newData.imageUrl is string || newData.imageUrl == null)) &&
        (!('visibility' in newData) || newData.visibility in ['public', 'members', 'private']) &&
        (!('status' in newData) || newData.status in ['scheduled', 'canceled', 'postponed', 'draft']) &&
        (!('isReadOnly' in newData) || newData.isReadOnly is bool);
    }
    
    // Check if user is event creator
    function isEventCreator(eventId) {
      return isSignedIn() && 
        exists(/databases/$(database)/documents/events/$(eventId)) &&
        get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid;
    }
    
    // Enhanced RSVP validation functions
    function validRSVPData(data) {
      return data is map &&
        ('eventId' in data) && isNonEmptyString(data.eventId) &&
        ('userId' in data) && isNonEmptyString(data.userId) &&
        ('status' in data) && data.status in ['going', 'not-going', 'waitlisted'] &&
        (!('adults' in data) || (data.adults is number && data.adults >= 0)) &&
        // childCounts can be:
        //  (A) list of maps: [{ageGroup:'0-2', count:1}, ...] (max 4), OR
        //  (B) map keyed by age group: {'0-2':1,'3-5':0,'6-10':2,'11':0}
        (!('childCounts' in data) ||
          (data.childCounts is list &&
           data.childCounts.size() <= 4 &&
           data.childCounts.size() >= 0 &&
           (data.childCounts.size() == 0 ||
             (data.childCounts[0] is map &&
              ('ageGroup' in data.childCounts[0]) &&
              ('count' in data.childCounts[0])))) ||
          (data.childCounts is map)) &&
        (!('guests' in data) || (data.guests is list && data.guests.size() <= 20)) &&
        (!('notes' in data) || (data.notes is string && data.notes.size() <= 1000)) &&
        (!('displayName' in data) || (data.displayName is string || data.displayName == null)) &&
        (!('email' in data) || (data.email is string || data.email == null));
    }
    
    // Helper function to check event capacity
    function checkEventCapacity(eventId, isGoingStatus) {
      let eventData = get(/databases/$(database)/documents/events/$(eventId)).data;
      
      return (!('maxAttendees' in eventData) || eventData.maxAttendees == null || !isGoingStatus) ? 
        true : 
        // Get current attendee count with 'going' status
        // Note: This is a simplified check - in practice, we rely on client-side validation
        // due to Firestore rules limitations with complex queries
        eventData.attendingCount < eventData.maxAttendees;
    }

    // Enhanced attendee validation functions
    function validAttendeeData(data) {
      return data is map &&
        // eventId is optional for updates (it's in the path), required for creates
        (!('eventId' in data) || (('eventId' in data) && isNonEmptyString(data.eventId))) &&
        ('userId' in data) && (data.userId is string || data.userId == null) &&
        ('attendeeType' in data) && data.attendeeType in ['primary', 'family_member', 'guest', 'real', 'ghost', 'offline_paid', 'vip', 'sponsor', 'volunteer', 'early_bird', 'group_booking'] &&
        ('relationship' in data) && data.relationship in ['self', 'spouse', 'child', 'guest'] &&
        ('name' in data) && isNonEmptyString(data.name) && data.name.size() >= 2 &&
        ('ageGroup' in data) && data.ageGroup in ['0-2', '3-5', '6-10', '11+', 'adult'] &&
        ('rsvpStatus' in data) && data.rsvpStatus in ['going', 'not-going', 'waitlisted'] &&
        (!('familyMemberId' in data) || (data.familyMemberId is string || data.familyMemberId == null));
    }
    
    // Validation function for attendee updates (supports partial updates)
    // Note: request.resource.data contains merged document (existing + updated fields)
    // This validation ensures that required fields exist (from existing doc) and new fields are valid
    function validAttendeeUpdateData(data) {
      return data is map &&
        // eventId is optional for updates (it's in the path)
        (!('eventId' in data) || (('eventId' in data) && isNonEmptyString(data.eventId))) &&
        // userId must exist (from existing document)
        ('userId' in data) && (data.userId is string || data.userId == null) &&
        // attendeeType must exist (from existing document)
        ('attendeeType' in data) && data.attendeeType in ['primary', 'family_member', 'guest', 'real', 'ghost', 'offline_paid', 'vip', 'sponsor', 'volunteer', 'early_bird', 'group_booking'] &&
        // relationship must exist (from existing document)
        ('relationship' in data) && data.relationship in ['self', 'spouse', 'child', 'guest'] &&
        // name must exist (from existing document)
        ('name' in data) && isNonEmptyString(data.name) && data.name.size() >= 2 &&
        // ageGroup must exist (from existing document)
        ('ageGroup' in data) && data.ageGroup in ['0-2', '3-5', '6-10', '11+', 'adult'] &&
        // rsvpStatus must exist (can be from existing doc or updated)
        ('rsvpStatus' in data) && data.rsvpStatus in ['going', 'not-going', 'waitlisted'] &&
        // familyMemberId is optional
        (!('familyMemberId' in data) || (data.familyMemberId is string || data.familyMemberId == null));
    }
    
    // Simplified validation for bulk attendee data
    function validBulkAttendeeData(data) {
      return data is map &&
        ('userId' in data) && (data.userId is string || data.userId == null) &&
        ('attendeeType' in data) && data.attendeeType in ['real', 'ghost', 'offline_paid', 'vip', 'sponsor', 'volunteer', 'early_bird', 'group_booking', 'family_member'] &&
        ('name' in data) && isNonEmptyString(data.name) && data.name.size() >= 2 &&
        ('rsvpStatus' in data) && data.rsvpStatus in ['going', 'not-going', 'waitlisted'] &&
        ('createdAt' in data) && data.createdAt is timestamp &&
        ('updatedAt' in data) && data.updatedAt is timestamp &&
        ('isDeleted' in data) && data.isDeleted is bool;
    }
    
    function validStatusHistory(history) {
      return history is list && 
         history.size() > 0 && 
         history[0] is map &&
         history[0].status is string &&
         history[0].status in ['going', 'not-going'] &&
         history[0].changedAt is timestamp && // Firestore converts Date to timestamp automatically
         history[0].changedBy is string;
    }
    
    // --- USERS ---
    match /users/{userId} {
      allow read: if isSignedIn() || 
        // Allow public read for basic user info (same as shown in events)
        (resource != null && resource.data.keys().hasOnly(['displayName', 'photoURL', 'displayNameLower', 'firstName', 'lastName'])) ||
        // Allow unauthenticated read for phone number validation during login
        (resource != null && 'phoneNumber' in resource.data);
      allow create: if isSignedIn() && 
        request.auth.uid == userId && 
        (!('role' in request.resource.data) || (request.resource.data.role == 'member' && !isBlockedPhone())) && 
        validUserProfileData(request.resource.data);
      allow update: if isSignedIn() && (
        (request.auth.uid == userId && 
         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role']) && 
         validUserProfileData(request.resource.data)) ||
        (isAdmin() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['blockedFromRsvp', 'updatedAt', 'fcmToken']) &&
         (!('fcmToken' in request.resource.data) || request.resource.data.fcmToken is string))
      );
      allow delete: if isSignedIn() && request.auth.uid == userId;
      
      // --- FAMILY MEMBERS ---
      match /familyMembers/{memberId} {
        allow read, write: if isSignedIn() && request.auth.uid == userId;
      }
    }
    
    // --- EVENT TEASERS ---
    match /event_teasers/{teaserId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }
    
    // --- USER BLOCKS ---
    match /userBlocks/{blockId} {
      allow read: if isSignedIn() && (
        request.auth.uid == resource.data.blockedByUserId || 
        request.auth.uid == resource.data.blockedUserId ||
        isAdmin()
      );
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.blockedByUserId;
      allow update: if isSignedIn() && (
        request.auth.uid == resource.data.blockedByUserId ||
        isAdmin()
      );
      allow delete: if isAdmin();
    }
    
    // --- BLOCK REPORTS ---
    match /blockReports/{reportId} {
      allow read: if isSignedIn() && (
        request.auth.uid == resource.data.reporterUserId ||
        isAdmin()
      );
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.reporterUserId;
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // --- MANUAL FIXES (Admin System Tools) ---
    match /manual_fixes/{fixId} {
      allow read, create, update, delete: if isAdmin();
    }
    
    // --- EVENTS (Enhanced) ---
    match /events/{eventId} {
      allow read: if
        // Past events: always readable by everyone (for history)
        resource.data.startAt < request.time ||
        // Public events: readable by everyone (including events with missing fields)
        (('visibility' in resource.data) && resource.data.visibility == 'public') ||
        // Legacy support: old 'public' field
        (('public' in resource.data) && resource.data.public == true) ||
        // Authenticated users can see events they're allowed to access
        (isSignedIn() && (
          // Event creator can see their own events
          resource.data.createdBy == request.auth.uid ||
          // Admin can see all events
          isAdmin() ||
          // Members can see members-only events
          (isMember() && (('visibility' in resource.data) && resource.data.visibility == 'members')) ||
          // Invited users can see private events (handle missing fields)
          (('invitedUserIds' in resource.data) && request.auth.uid in resource.data.invitedUserIds) ||
          // Legacy support: old invitedUsers field
          (('invitedUsers' in resource.data) && request.auth.uid in resource.data.invitedUsers)
        ));
      
      // Enhanced create/update/delete permissions
      allow create: if isSignedIn() && 
        (isMember() || isAdmin()) && 
        request.auth.uid == request.resource.data.createdBy &&
        validEventData(request.resource.data);
      
      allow update: if isSignedIn() && 
        (isAdmin() || isEventCreator(eventId) ||
         // Allow users to update only specific fields for RSVP purposes
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attendingCount', 'updatedAt'])));
      
      allow delete: if isSignedIn() && 
        (isAdmin() || isEventCreator(eventId));
      
      // Enhanced RSVP management with blocking support
      match /rsvps/{userId} {
        allow read: if isSignedIn();
        
        allow create: if (isMember() || isAdmin()) && 
          request.auth.uid == userId && 
          request.resource.data.eventId == eventId &&
          request.resource.data.userId == userId &&
          // Simple permission check: allow RSVP if user can see the event
          (
            // Public events: anyone can RSVP
            get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'public' ||
            // Event creator can always RSVP
            request.auth.uid == get(/databases/$(database)/documents/events/$(eventId)).data.createdBy ||
            // Invited users can RSVP to private events
            (get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'private' && 
             request.auth.uid in get(/databases/$(database)/documents/events/$(eventId)).data.invitedUserIds)
          );
        
        allow update: if (isMember() || isAdmin()) &&
          (request.auth.uid == userId || isAdmin()) &&
          request.resource.data.eventId == eventId &&
          request.resource.data.userId == userId &&
          validRSVPData(request.resource.data);
        
        // Enhanced: Allow admins to modify any RSVP
        allow delete: if isSignedIn() && 
          (request.auth.uid == userId || isAdmin());
      }

      // Attendees subcollection - SECURE VERSION
      match /attendees/{attendeeId} {
        // Allow public read access for public events (for RSVP counts)
        // Authenticated users can read attendees for events they have access to
        allow read: if 
          // Public events: anyone can read (for RSVP counts)
          (get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'public' ||
           (!('visibility' in get(/databases/$(database)/documents/events/$(eventId)).data) && 
            get(/databases/$(database)/documents/events/$(eventId)).data.public == true)) ||
          // Authenticated users can read attendees for events they have access to
          (isSignedIn() && (
            // Event creator can read all attendees
            get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid ||
            // Admin can read all attendees
            isAdmin() ||
            // User can read their own household attendees (most important)
            resource.data.userId == request.auth.uid ||
            // Members can read attendees for members-only events
            (isMember() && get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'members') ||
            // Users can read attendees for private events if they are invited
            (get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'private' && 
             request.auth.uid in get(/databases/$(database)/documents/events/$(eventId)).data.invitedUserIds) ||
            // Fallback: Allow any authenticated user to read their own attendees for public events
            (get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'public' &&
             resource.data.userId == request.auth.uid)
          ));
        
        // Users can create attendees for events they have access to
        allow create: if isSignedIn() && 
          validAttendeeData(request.resource.data) &&
          // Skip capacity check for family members (they can exceed capacity)
          // Also skip capacity check for authenticated members creating their own primary attendees (they can go to waitlist)
          (request.resource.data.attendeeType == 'family_member' || 
           (request.resource.data.userId == request.auth.uid && request.resource.data.attendeeType == 'primary') ||
           checkEventCapacity(eventId, request.resource.data.rsvpStatus == 'going')) &&
          (
            // Event creator can add attendees (including bulk uploads)
            get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid ||
            // Admin can add attendees (including bulk uploads)
            isAdmin() ||
            // Bulk upload attendees (offline_paid, ghost, etc.) - allow if user is event creator or admin
            (request.resource.data.userId == null && 
             (get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid || isAdmin())) ||
            // Regular users can add their own attendees
            (request.resource.data.userId == request.auth.uid &&
             (// Users can add attendees to public events (with fallback for legacy events)
              (get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'public' ||
               (!('visibility' in get(/databases/$(database)/documents/events/$(eventId)).data) && 
                get(/databases/$(database)/documents/events/$(eventId)).data.public == true)) ||
              // Members can add attendees to members-only events
              (isMember() && get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'members') ||
              // Invited users can add attendees to private events
              (get(/databases/$(database)/documents/events/$(eventId)).data.visibility == 'private' && 
               request.auth.uid in get(/databases/$(database)/documents/events/$(eventId)).data.invitedUserIds) ||
              // CRITICAL FALLBACK: Allow any authenticated member to create their own primary attendees
              // This ensures RSVP works even if event visibility is not properly configured
              (isMember() && request.resource.data.attendeeType == 'primary') ||
              // FINAL FALLBACK: Allow any authenticated user to create their own primary attendees
              // This is a catch-all to ensure RSVP works even if user role/event visibility is misconfigured
              (isSignedIn() && request.resource.data.attendeeType == 'primary')
            )) ||
            // Enhanced fallback: Allow authenticated users to add family members to ANY event
            // This ensures family member addition works even if event visibility/permissions are misconfigured
            (isSignedIn() && request.resource.data.attendeeType == 'family_member' && request.resource.data.userId == request.auth.uid) ||
            // FINAL FALLBACK: Allow any authenticated user to create their own primary attendees as last resort
            // This ensures RSVP works even if all other checks fail
            (isSignedIn() && request.resource.data.userId == request.auth.uid && request.resource.data.attendeeType == 'primary')
          );
        
        // TEMPORARY RULE REMOVED - Security vulnerability fixed
        
        // Users can update their own attendees, event creators can update all attendees
        allow update: if isSignedIn() && (
          request.resource.data.userId == request.auth.uid ||
          get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid ||
          isAdmin()
        ) && 
        // Validate only fields that are being updated (partial updates allowed)
        // request.resource.data contains merged document (existing + updated fields)
        (!('eventId' in request.resource.data) || (('eventId' in request.resource.data) && isNonEmptyString(request.resource.data.eventId))) &&
        (!('userId' in request.resource.data) || (request.resource.data.userId is string || request.resource.data.userId == null)) &&
        (!('attendeeType' in request.resource.data) || (request.resource.data.attendeeType in ['primary', 'family_member', 'guest', 'real', 'ghost', 'offline_paid', 'vip', 'sponsor', 'volunteer', 'early_bird', 'group_booking'])) &&
        (!('relationship' in request.resource.data) || (request.resource.data.relationship in ['self', 'spouse', 'child', 'guest'])) &&
        (!('name' in request.resource.data) || (isNonEmptyString(request.resource.data.name) && request.resource.data.name.size() >= 2)) &&
        (!('ageGroup' in request.resource.data) || (request.resource.data.ageGroup in ['0-2', '3-5', '6-10', '11+', 'adult'])) &&
        (!('rsvpStatus' in request.resource.data) || (request.resource.data.rsvpStatus in ['going', 'not-going', 'waitlisted'])) &&
        (!('familyMemberId' in request.resource.data) || (request.resource.data.familyMemberId is string || request.resource.data.familyMemberId == null)) &&
        // Check capacity when changing status to 'going'
        // Strategy: Trust client-side logic - allow 'waitlisted' and 'not-going' always
        // Only block 'going' status if event is full AND no waitlist available
        (isAdmin() ||
         get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid ||
         request.resource.data.attendeeType == 'family_member' ||
         resource.data.attendeeType == 'family_member' ||
         // Always allow 'waitlisted' or 'not-going' status (client handles logic)
         request.resource.data.rsvpStatus == 'waitlisted' ||
         request.resource.data.rsvpStatus == 'not-going' ||
         // Allow if already 'going' (no change to status)
         resource.data.rsvpStatus == 'going' ||
         // Allow if changing FROM waitlisted to going (promotion from waitlist)
         resource.data.rsvpStatus == 'waitlisted' ||
         // For 'going' status: allow if waitlist enabled (client will auto-waitlist) OR if capacity available
         (request.resource.data.rsvpStatus == 'going' &&
          (get(/databases/$(database)/documents/events/$(eventId)).data.waitlistEnabled == true ||
           checkEventCapacity(eventId, true))));
        
        // Users can delete their own attendees, event creators can delete all attendees
        allow delete: if isSignedIn() && (
          resource.data.userId == request.auth.uid ||
          get(/databases/$(database)/documents/events/$(eventId)).data.createdBy == request.auth.uid ||
          isAdmin()
        );
      }
    }
    
    // --- RSVPs Collection Group Access (for cross-event queries) ---
    // Allow users to read/write their own RSVP docs across all events
    match /{path=**}/rsvps/{rsvpId} {
      allow read, get, list: if request.auth != null
                              && (resource.data.userId == request.auth.uid || 
                                  // Allow event creators to read RSVPs for their events
                                  (resource.data.eventId != null && 
                                   exists(/databases/$(database)/documents/events/$(resource.data.eventId)) &&
                                   get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.createdBy == request.auth.uid));
      
      // Allow users to create/update their own RSVPs (delegated to subcollection rules)
      allow create: if false; // Use specific subcollection rules instead
      allow update: if false; // Use specific subcollection rules instead
      allow delete: if false; // Use specific subcollection rules instead
    }
    
    // --- POSTS ---
    match /posts/{postId} {
      allow read: if (('isPublic' in resource.data) && resource.data.isPublic == true) || 
        isMember() || isAdmin();
      
      allow create: if isSignedIn() && 
        request.auth.uid == request.resource.data.authorId &&
        !isUserBlockedFromRsvp(request.auth.uid);
      
      allow update, delete: if isSignedIn() && 
        (request.auth.uid == resource.data.authorId || isAdmin());
      
      match /likes/{userId} {
        allow read: if true;
        allow create: if isSignedIn() && 
          request.auth.uid == userId && 
          request.resource.data.keys().hasOnly(['userId','createdAt']) && 
          request.resource.data.userId == userId;
        allow update: if false;
        allow delete: if isSignedIn() && 
          (request.auth.uid == userId || isAdmin());
      }
      
      match /comments/{commentId} {
        allow read: if true;
        allow create: if isSignedIn() && 
          request.auth.uid == request.resource.data.authorId && 
          (isNonEmptyString(request.resource.data.text) || ('mediaUrls' in request.resource.data && request.resource.data.mediaUrls is list)) && 
          (!('text' in request.resource.data) || request.resource.data.text.size() <= 1000) && 
          request.resource.data.keys().hasOnly(['authorId','authorName','text','mediaUrls','createdAt','threadLevel','parentCommentId','replyCount']) &&
          !isUserBlockedFromRsvp(request.auth.uid);
        allow update: if isSignedIn() && 
          (request.auth.uid == resource.data.authorId || isAdmin()) && 
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['text','updatedAt']);
        allow delete: if isSignedIn() && 
          (request.auth.uid == resource.data.authorId || isAdmin());
        
        // Comment likes subcollection
        match /likes/{userId} {
          allow read: if true;
          allow create: if isSignedIn() && 
            request.auth.uid == userId && 
            request.resource.data.keys().hasOnly(['userId','createdAt']) && 
            request.resource.data.userId == userId;
          allow update: if false;
          allow delete: if isSignedIn() && 
            (request.auth.uid == userId || isAdmin());
        }
        
         // Comment reactions subcollection - compound key userId_emoji
         match /reactions/{userId_emoji} {
           allow read: if true;
           allow create: if isSignedIn() && 
             request.auth.uid == request.resource.data.userId && 
             request.resource.data.keys().hasOnly(['userId','emoji','createdAt']) && 
             request.resource.data.userId == request.auth.uid &&
             request.resource.data.emoji in ['â¤ï¸','ðŸ˜‚','ðŸ˜®','ðŸ‘','ðŸ‘Ž','ðŸ˜¢','ðŸ˜¡'] &&
             userId_emoji == request.resource.data.userId + '_' + request.resource.data.emoji;
           allow update: if false;
           allow delete: if isSignedIn() && 
             (request.auth.uid == resource.data.userId || isAdmin());
         }
      }
    }
    
    // --- TESTIMONIALS ---
    match /testimonials/{testimonialId} {
      allow read: if resource != null && (
        resource.data.status == 'published' ||
        (isSignedIn() && (isAdmin() || resource.data.userId == request.auth.uid))
      );

      allow create: if isSignedIn()
        && request.resource.data.keys().hasOnly([
          'userId',
          'displayName',
          'quote',
          'rating',
          'status',
          'featured',
          'createdAt',
          'updatedAt',
          'highlight',
          'avatarUrl',
          'toneLabel',
          'toneConfidence',
          'toneKeywords'
        ])
        && request.resource.data.userId == request.auth.uid
        && isNonEmptyString(request.resource.data.displayName)
        && isNonEmptyString(request.resource.data.quote)
        && request.resource.data.quote.size() >= 20
        && request.resource.data.quote.size() <= 2000
        && isValidRating(request.resource.data.rating)
        && request.resource.data.status == 'pending'
        && isAllowedTestimonialStatus(request.resource.data.status)
        && ('createdAt' in request.resource.data) && request.resource.data.createdAt is timestamp
        && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt is timestamp)
        && (!('featured' in request.resource.data) || request.resource.data.featured == false)
        && (!('avatarUrl' in request.resource.data) || isUrlLike(request.resource.data.avatarUrl))
        && (!('highlight' in request.resource.data) || (request.resource.data.highlight is string && request.resource.data.highlight.size() <= 120))
        && (!('toneLabel' in request.resource.data) || (request.resource.data.toneLabel is string && request.resource.data.toneLabel.size() <= 40))
        && (!('toneConfidence' in request.resource.data) || (request.resource.data.toneConfidence is number && request.resource.data.toneConfidence >= 0 && request.resource.data.toneConfidence <= 1))
        && (!('toneKeywords' in request.resource.data) || (request.resource.data.toneKeywords is list && request.resource.data.toneKeywords.size() <= 5));

      allow update: if isSignedIn() && isAdmin()
        && request.resource.data.keys().hasOnly([
          'userId',
          'displayName',
          'quote',
          'rating',
          'status',
          'featured',
          'createdAt',
          'updatedAt',
          'highlight',
          'avatarUrl',
          'reviewedBy',
          'reviewedAt',
          'publishedAt',
          'toneLabel',
          'toneConfidence',
          'toneKeywords'
        ])
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.createdAt == resource.data.createdAt
        && isNonEmptyString(request.resource.data.displayName)
        && isNonEmptyString(request.resource.data.quote)
        && request.resource.data.quote.size() >= 10
        && request.resource.data.quote.size() <= 2000
        && isValidRating(request.resource.data.rating)
        && isAllowedTestimonialStatus(request.resource.data.status)
        && request.resource.data.updatedAt is timestamp
        && (!('avatarUrl' in request.resource.data) || request.resource.data.avatarUrl == resource.data.avatarUrl || isUrlLike(request.resource.data.avatarUrl))
        && (!('highlight' in request.resource.data) || (request.resource.data.highlight is string && request.resource.data.highlight.size() <= 120))
        && (!('reviewedBy' in request.resource.data) || request.resource.data.reviewedBy == null || request.resource.data.reviewedBy is string)
        && (!('reviewedAt' in request.resource.data) || request.resource.data.reviewedAt is timestamp)
        && (!('publishedAt' in request.resource.data) || request.resource.data.publishedAt == null || request.resource.data.publishedAt is timestamp)
        && (!('toneLabel' in request.resource.data) || (request.resource.data.toneLabel is string && request.resource.data.toneLabel.size() <= 40))
        && (!('toneConfidence' in request.resource.data) || (request.resource.data.toneConfidence is number && request.resource.data.toneConfidence >= 0 && request.resource.data.toneConfidence <= 1))
        && (!('toneKeywords' in request.resource.data) || (request.resource.data.toneKeywords is list && request.resource.data.toneKeywords.size() <= 5));

      allow delete: if isSignedIn() && (
        isAdmin() ||
        (resource.data.userId == request.auth.uid && resource.data.status != 'published')
      );
    }

    // --- AI Prompts Configuration (Admin Only) ---
    match /aiPrompts/{promptId} {
      allow read: if isSignedIn(); // Any authenticated user can read (for AI function calls)
      allow write: if isAdmin(); // Only admins can update prompts
    }
    
    // --- MEDIA ---
    match /media/{mediaId} {
      allow read: if true; // Anyone can read all media
      allow create: if isSignedIn() && 
        request.auth.uid == request.resource.data.uploadedBy;
      allow update, delete: if isSignedIn() && 
        (request.auth.uid == resource.data.uploadedBy || isAdmin()) ||
        // Allow view counter updates for all users (including guests)
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewsCount']));
      
      match /likes/{userId} {
        allow read: if true;
        allow create: if isSignedIn() && 
          request.auth.uid == userId && 
          request.resource.data.keys().hasOnly(['userId','createdAt']) && 
          request.resource.data.userId == userId;
        allow update: if false;
        allow delete: if isSignedIn() && 
          (request.auth.uid == userId || isAdmin());
      }
      
      match /comments/{commentId} {
        allow read: if true;
        allow create: if isSignedIn() && 
          request.auth.uid == request.resource.data.authorId && 
          (isNonEmptyString(request.resource.data.text) || ('mediaUrls' in request.resource.data && request.resource.data.mediaUrls is list)) && 
          (!('text' in request.resource.data) || request.resource.data.text.size() <= 1000) && 
          request.resource.data.keys().hasOnly(['authorId','authorName','text','mediaUrls','createdAt','threadLevel','parentCommentId','replyCount']) &&
          !isUserBlockedFromRsvp(request.auth.uid);
        allow update: if isSignedIn() && 
          (request.auth.uid == resource.data.authorId || isAdmin()) && 
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['text','updatedAt']);
        allow delete: if isSignedIn() && 
          (request.auth.uid == resource.data.authorId || isAdmin());
        
        // Comment likes subcollection
        match /likes/{userId} {
          allow read: if true;
          allow create: if isSignedIn() && 
            request.auth.uid == userId && 
            request.resource.data.keys().hasOnly(['userId','createdAt']) && 
            request.resource.data.userId == userId;
          allow update: if false;
          allow delete: if isSignedIn() && 
            (request.auth.uid == userId || isAdmin());
        }
        
         // Comment reactions subcollection - compound key userId_emoji
         match /reactions/{userId_emoji} {
           allow read: if true;
           allow create: if isSignedIn() && 
             request.auth.uid == request.resource.data.userId && 
             request.resource.data.keys().hasOnly(['userId','emoji','createdAt']) && 
             request.resource.data.userId == request.auth.uid &&
             request.resource.data.emoji in ['â¤ï¸','ðŸ˜‚','ðŸ˜®','ðŸ‘','ðŸ‘Ž','ðŸ˜¢','ðŸ˜¡'] &&
             userId_emoji == request.resource.data.userId + '_' + request.resource.data.emoji;
           allow update: if false;
           allow delete: if isSignedIn() && 
             (request.auth.uid == resource.data.userId || isAdmin());
         }
      }
    }
    
    // --- SPONSORS ---
    match /sponsors/{sponsorId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
      
      match /promotions/{promotionId} {
        allow read: if true;
        allow create, update, delete: if isAdmin();
      }
    }
    
    // --- NOTIFICATIONS (Enhanced) ---
    match /notifications/{notificationId} {
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      
      // Allow admins to create notifications (for system notifications)
      allow create: if isAdmin();
      
      // Allow users to update only their own notifications (mark as read)
      allow update: if request.auth != null && 
        request.auth.uid == resource.data.userId && 
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['read', 'updatedAt']);
      
      // Allow admins to delete notifications
      allow delete: if isAdmin();
    }
    
    // --- CONTACT MESSAGES ---
    match /contactMessages/{messageId} {
      // Allow anyone to create contact messages (for the contact form)
      allow create: if true;
      
      // Only admins can read, update, or delete contact messages
      allow read, update, delete: if isAdmin();
    }
    
    // --- POPUP ALERTS ---
    match /popup_alerts/{alertId} {
      // Allow authenticated users to read popup alerts
      allow read: if isSignedIn();
      
      // Only admins can create, update, or delete popup alerts
      allow create, update, delete: if isAdmin();
    }
    
    // --- PUSH NOTIFICATION QUEUE ---
    match /push_notification_queue/{messageId} {
      // Allow authenticated users to read their own queued messages
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
      
      // Only admins can create, update, or delete queued messages
      allow create, update, delete: if isAdmin();
    }
    
    // --- SMS QUEUE ---
    match /sms_queue/{messageId} {
      // Allow authenticated users to read their own queued SMS
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
      
      // Only admins can create, update, or delete queued SMS
      allow create, update, delete: if isAdmin();
    }
    
    // --- PAYMENT TRANSACTIONS ---
    match /payment_transactions/{transactionId} {
      // Users can read their own payment transactions, admins can read all
      allow read: if isSignedIn() && (request.auth.uid == resource.data.userId || isAdmin());
      
      // Users can create payment transactions for their own RSVPs
      allow create: if isSignedIn() && 
        request.auth.uid == request.resource.data.userId &&
        isNonEmptyString(request.resource.data.eventId) &&
        isNonEmptyString(request.resource.data.attendeeId) &&
        request.resource.data.amount is number &&
        request.resource.data.amount >= 0 &&
        isNonEmptyString(request.resource.data.currency) &&
        isNonEmptyString(request.resource.data.status) &&
        request.resource.data.status in ['pending', 'paid', 'failed', 'refunded'] &&
        isNonEmptyString(request.resource.data.method) &&
        request.resource.data.method in ['card', 'bank_transfer', 'cash', 'other'] &&
        request.resource.data.refundStatus in ['none', 'partial', 'full', 'requested'];
      
      // Users can update their own payment transactions, admins can update any
      allow update: if isSignedIn() && (
        request.auth.uid == resource.data.userId ||
        isAdmin()
      );
      
      // Only admins can delete payment transactions
      allow delete: if isAdmin();
    }
    
    // --- PAYMENT CONFIGURATION ---
    match /payment_config/{configId} {
      // Only admins can read payment configuration
      allow read: if isAdmin();
      
      // Only admins can create/update payment configuration
      allow create, update: if isAdmin();
      
      // Only admins can delete payment configuration
      allow delete: if isAdmin();
    }
    
    // --- REFUND REQUESTS ---
    match /refund_requests/{requestId} {
      // Users can read their own refund requests, admins can read all
      allow read: if isSignedIn() && (request.auth.uid == resource.data.userId || isAdmin());
      
      // Users can create refund requests for their own payments
      allow create: if isSignedIn() && 
        request.auth.uid == request.resource.data.userId &&
        isNonEmptyString(request.resource.data.paymentId) &&
        isNonEmptyString(request.resource.data.eventId) &&
        request.resource.data.requestedAmount is number &&
        request.resource.data.requestedAmount > 0 &&
        isNonEmptyString(request.resource.data.reason) &&
        request.resource.data.status == 'pending';
      
      // Only admins can update refund requests (approve/reject)
      allow update: if isAdmin();
      
      // Only admins can delete refund requests
      allow delete: if isAdmin();
    }
    
    // --- Fallback for stray comments ---
    match /{parentPath=**}/comments/{commentId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && 
        request.auth.uid == request.resource.data.authorId && 
        isNonEmptyString(request.resource.data.text) && 
        request.resource.data.text.size() <= 1000;
      allow update, delete: if isSignedIn() && 
        (request.auth.uid == resource.data.authorId || isAdmin());
    }
    
    // =========================
    // Admin Logs (admin only): adminLogs/{...}
    // =========================
    match /adminLogs/{logId} {
      allow read, write: if isSignedIn() && isAdmin();
    }
    
    // --- Default Security: Deny all unknown collections ---
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
